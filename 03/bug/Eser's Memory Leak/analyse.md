以下是Eser关于内存泄漏的一些个人理解


## 关于c/c++

因为之前打c和c++比较多，并不是很清楚java的内存泄漏是怎么造成的。

在c/c++程序里面内存泄漏指的是在堆中还没有被释放也没有指针指向其地址的内存块，也就是程序员通过new或者malloc等方式申请了一段内存，结果却把指向这块内存的指针给丢了，那么这块内存就是实际存在却无法利用得到的，也就是发生泄漏了

## 关于java

虽然没怎么写java但至少还是知道java的GC机制的，所以一开始很不能理解为什么java也能发生内存泄漏，因为一旦通向某个内存块的引用全没了，那么该内存块肯定也就被GC给回收了。

看了一些样例程序之后发现先前观念是对内存泄漏的狭隘定义造成的。按照其本意，应是某块不会被用到的内存块**没有被回收仍占着内存**，因此才有了那个经典的vector里面不断new出object，然后就说这就是造成内存泄漏的例子（当然这个例子在我看来也是不太恰当的）

正如在src里面的程序所注释的，在vector正在被使用的时候，上述程序所产生的应该不算内存泄漏，只有当vector被用完之后而vector引用本身又还没被回收的那段代码才算是内存泄漏。当然啦，在vector引用本身也被回收了之后，上面的一系列对象也会被回收。

所以，从另外一个角度，要让java内存泄漏达到一个明显可观测的角度（用jstat,jhist等工具），其实就是写个不断new出对象而造成**内存溢出**的java程序而已。

## 最后的思考总结

所以java的内存泄漏就只是不断new对象造成的内存溢出吗？但是本质上只要我们管理好那些new出来的对象的引用不就好了吗？毕竟他们还是存在是accessible的，不像c++丢了指针就不可能再找回来了啊？这难道不是一些SB程序员自己没管理好自己搞出来的引用而已嚒？和c++相比起来算什么内存泄漏？

后来想了想，好像c++的内存泄漏也是SB程序员员管理好自己的指针......

